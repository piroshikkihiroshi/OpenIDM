package htmlMaskTest;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.apache.log4j.Logger;

public class HtmlMaskTest_Gr外側は無理そうだからロールバック {
	static Logger objLog = Logger.getLogger(HtmlMaskTest_Gr外側は無理そうだからロールバック.class);

	public static void main(String[] args) {

		HtmlMaskTest_Gr外側は無理そうだからロールバック objMe = new HtmlMaskTest_Gr外側は無理そうだからロールバック();
		FileWriter file;
		PrintWriter pw;

		//全文検索モックデータ カンマ区切りで番号が来ると予想 intpos,そこからつづく,intpos,そこからつづく
		//※開始は1文字目から
		//		String strTestData = "9,3,30,2";
		//		String strTestData = "1,2,9,10,100,2,105,2";
		//		String strTestData = "200,20";
		//		String strTestData = "0,2,9,3,100,2";
		//		String strTestData = "2,8";
		//		String strTestData = "2,2,5,2";
		//		String strTestData = "2,10a";
//		String strTestData = "2,1,4,6";
		String strTestData = "2,10,13,5";
		//		String strTestData = "19,2";
		//htmlをすべて読み込む
		//		String strDir = "//yoks3104/Project/NES_文書管理システム/99_tmp/上田/aspTest/";
		//		String strDir = "C:/Users/ueda tatsuya/Desktop/20190826/20190826/repTest/";
		String strDir = "C:/Users/ueda tatsuya/Desktop/repTest/";
		String strFileName = "test.docasp_1566802594082.html";
		//		String strFileName = "test_黒塗り調査用.html";
		String strDlFilePath = strDir + strFileName;
		String strAllHtml = "";
		String strOrgBody = "";
		String strNotTagBody = "";
		String strRepBody = "";
		String strMaskHtml = "";
		int intMaskStatsu = 1;

		try {
			strAllHtml = objMe.readAll(strDlFilePath);

			//圧縮されたBodyを取得
			strOrgBody = objMe.getBodyCompress(strAllHtml);

			//全文検索エンジンに渡す用の文字列を取得する
			strNotTagBody = objMe.getIllegalText(strOrgBody);

			//			※※※※※※※検索エンジンに送ったと想定※※※※※※※

			//全文検索から戻ってきた値をhashへ成型
			HashMap<Integer, Integer> hashRetGr = new HashMap<Integer, Integer>(); //連続処理のグループ
//			HashMap<Integer, Integer> hashRepPos = objMe.makePosHash(strTestData,hashRetGr);
			HashMap<Integer, HashMap<Integer, Integer>> hashRepPos = objMe.makePosHash(strTestData,hashRetGr);
			objMe.makePosHash(strTestData,hashRetGr);

			//全文検索エンジンに返した結果を置換してbodyを入れ替えた文字列を取得

			//hashRetGr_i毎に処理
			strRepBody = strOrgBody;
			for (Map.Entry<Integer, Integer> entActGr : hashRetGr.entrySet()) {
				HashMap<Integer, Integer> hashActPos = hashRepPos.get(entActGr.getKey());
//				strRepBody = objMe.bodyReplace(hashRepPos, strRepBody, strNotTagBody, intMaskStatsu, entActGr);
				strRepBody = objMe.bodyReplace(hashActPos, strRepBody, strNotTagBody, intMaskStatsu, entActGr);
			} //for

//			strRepBody = objMe.bodyReplace(hashRepPos, strOrgBody, strNotTagBody, intMaskStatsu,hashRetGr);
			//htmlのbodyの中身を入れ替え、置換HTMLを作成する
			strMaskHtml = objMe.makeBody(strAllHtml, strRepBody);

			//htmlを出力する
			//			//debug tmpに出力
			file = new FileWriter(strDir + "test.html");
			pw = new PrintWriter(new BufferedWriter(file));
			pw.println(strMaskHtml);
			pw.close();
			objLog.info("完了");

			//			System.out.println(strOrgBody);

		} catch (IOException e) {
			// TODO 自動生成された catch ブロック
			e.printStackTrace();
		} //try

	} //main


	/**
	 * 全文検索エンジンに返した結果を置換してbodyを入れ替え、または赤文字変換した文字列を取得
	 * @param hashTest
	 * @param strOrgBody_i
	 * @param intStatus_i 置換ステータス :マスク 2:赤文字
	 * @return 置換したBody文字列
	 */
	public String bodyReplace(
			HashMap<Integer, Integer> hashRepPos_i,
			String strOrgBody_i,
			String strOrgTagDelBody_i,
			int intStatus_i,
			Entry<Integer, Integer> entActGr_i) {
		String strTgtVal = strOrgBody_i;

		String strRegrep = "(<\\/?[^>]+>)|([^<]+)"; //タグを覗いた値を取得する
		Pattern objPattern = Pattern.compile(strRegrep);
		Matcher objMatch = objPattern.matcher(strTgtVal);

		int intPos = 0; //tagを覗いた文字列の距離
		int intTagPos = 0; //タグを含めたstrが始まるまでの距離
		String strCurrentKwd = ""; //現在ヒットしている単語
		int intTagOffset = 0; //連続文字処理中にあるタグの分の文字数をカウント
		HashMap<String, Integer> hashKwdPos = new HashMap<String, Integer>(); //strCurrentKwdのポジションを格納する key:キーワード val：ポジション
		while(objMatch.find()){
			strCurrentKwd = objMatch.group(2);
			if (strCurrentKwd == null) {
				continue; //タグに文字列にマッチはスキップ
			} //if

			if (strCurrentKwd.equals(" "))
				continue; //半角スペースはスキップ
			if (hashKwdPos.containsKey(strCurrentKwd)) { //すでにKeyに入っているか確認
				hashKwdPos.put(strCurrentKwd, hashKwdPos.get(strCurrentKwd) + 1); //次の検索へ
			} else {
				hashKwdPos.put(strCurrentKwd, 0); //最初の検索
			} //if


			intTagPos = objMatch.start() + 1;
			String strRremainTag = strTgtVal.substring(intTagPos -1,strTgtVal.length()); //tagを含めた残りの文字
			String strRremainStr = getIllegalText(strRremainTag); //タグを覗いた残りのstring
			String strAcriveStr = getIllegalText(strTgtVal); //変換後のタグを覗いた全てのstring
			intPos = strAcriveStr.indexOf(strRremainStr) + 1;

			boolean blActFlg = false; //処理を行うかのフラグ

			for (int intKey : hashRepPos_i.keySet()) {
				if (hashRepPos_i.containsKey(intPos + (intKey - 1) )) {
					if(hashRepPos_i.get(intPos + (intKey - 1) ) == 0) { //未処理の場合だけフラグを建てる
						blActFlg = true;
						intPos = intPos + (intKey - 1); //スタートを切り替える
						break;
					}//if

				} //if
			} //for

			if(blActFlg) {
				HashMap<String, String> refHashRet = new HashMap<String, String>();
				refHashRet.put("strRepBody",strTgtVal);
				refHashRet.put("intInit","1");
				refHashRet.put("strAfter", strRremainTag);

				bodyRecursAct(hashRepPos_i, refHashRet, strOrgTagDelBody_i, intPos, intTagPos, intTagOffset,entActGr_i);
				strTgtVal = refHashRet.get("strRepBody");
			} //if

		}  //while // マッチした数だけループする

		return strTgtVal;
	} //bodyReplace


	/**
	 * HTMLタグがある限り再帰処理で置換、色変更を行う
	 * @param hashRepPos_i 全文検索に渡して加工した文字列置換する情報
	 * @param strOrgTagDelBody_i オリジナルタグ抜き文字
	 * @param intPos_i tagを覗いた文字列の距離
	 * @param intTagPos_i タグを含めたstrが始まるまでの距離
	 * @param entActGr_i 全文検索に渡して加工した文字列置換する情報のグループ
	 * @return
	 */
	public void bodyRecursAct(HashMap<Integer, Integer> hashRepPos_i,
			HashMap<String, String> refHashRet_i,
			String strOrgTagDelBody_i,
			int intPos_i,
			int intTagPos_i,
			int intTagOffset_i,
			Entry<Integer, Integer> entActGr_i
			) {
		String strRepBody_i = refHashRet_i.get("strRepBody");
		String strRegrep = "(<\\/?[^>]+>)|([^<]+)"; //タグを覗いた値を取得する
		Pattern objPattern = Pattern.compile(strRegrep);
		String strAfter ="";
		Matcher objNextMatch = null;
		String strBfTag="";
		HashMap<String, Integer> hashNextKwdPos=new HashMap<String, Integer>();
		if(refHashRet_i.get("intInit").equals("1")) { //初期処理
			strAfter = refHashRet_i.get("strAfter"); //前処理のタグと合わせることでで再帰処理とstrAfterをあわせる
		}else {

			//対象が全てタグで囲われているパターンを想定してオフセットなし
			strAfter = strRepBody_i.substring(intTagPos_i, strRepBody_i.length());
			//最初の閉じタグまで削除
			strAfter = strAfter.replaceFirst("^.+?>", "");
		} //if
		objNextMatch = objPattern.matcher(strAfter);

		while(objNextMatch.find()){
			String strNextCurrentKwd = objNextMatch.group(2);
			if (strNextCurrentKwd == null) {
				strBfTag+=objNextMatch.group(); //検索にかかったタグをあつめておく
				continue; //タグに文字列にマッチはスキップ
			} //if
			if (strNextCurrentKwd.equals(" "))
				continue; //半角スペースはスキップ
			if (hashNextKwdPos.containsKey(strNextCurrentKwd)) { //すでにKeyに入っているか確認
				hashNextKwdPos.put(strNextCurrentKwd, hashNextKwdPos.get(strNextCurrentKwd) + 1); //次の検索へ
			} else {
				hashNextKwdPos.put(strNextCurrentKwd, 0); //最初の検索
			} //if

			int intNextTagPos=0;
			String strRremainTag = "";
			//最初の閉じタグまで削除
			strRremainTag = strAfter.substring(strBfTag.length(),strAfter.length());
			String strRremainStr = getIllegalText(strRremainTag); //タグを覗いた残りのstring
			objLog.debug("現在のタグ抜き文字「"+strRremainStr+"」");
			//intNextTagPosを切り替える
			intNextTagPos = strRepBody_i.indexOf(strRremainTag) + 1;

			//strAcriveStrではなくオリジナルのタグ抜き
			int intNextPos = strOrgTagDelBody_i.indexOf(strRremainStr) + 1;

			//hashRetGr_i毎に処理
//			for (Map.Entry<Integer, Integer> entActGr : entActGr_i.entrySet()) {
				int intInitPos = 0; //現Grのスタート
				int intEndPos = 0; //現Grのエンド

				//現在のGrの連続する距離を出す
//				intInitPos = entActGr.getKey();
//				intEndPos = entActGr.getValue();
				intInitPos = entActGr_i.getKey();
				intEndPos = entActGr_i.getValue();



				String strTgtTag="";

				//連続処理中にタグが含まれるか判定する
				//intTagOffset_iが0と呼ぶメソッド変更
				HashMap<String, String> hashBeteen=null;

				hashBeteen = chkTagBeteen(hashRepPos_i, strRepBody_i, intPos_i, intNextTagPos,entActGr_i,strRremainTag,intTagOffset_i);

				String strCheckTag = hashBeteen.get("strCheckTag"); //連続するhashRepPos_iの中にタグが含まれているか判定
				boolean blMatchBiteen = hashBeteen.get("blMatchBiteen").equals("true");
				int intPartTagPos = Integer.parseInt(hashBeteen.get("intPartTagPos"));

				objLog.info("処理対象Gr.「"+intInitPos+"」処理対象文字「" + strNextCurrentKwd + "」");

					if (blMatchBiteen) { //部分的にタグが入っている場合
						objLog.info("「" +strCheckTag +"」は連続した文字列内にタグが含まれいるので特殊処理します。");
						if(intTagOffset_i==0) { //再帰処理準備
							for (int i = intInitPos; i < intInitPos + intEndPos; i++) {
								if (intInitPos + intPartTagPos -2< i) { //タグの途中などのポジション以上なら自身を再帰呼び出し
									strTgtTag = "";
									int intTmpPos=0;
									intTmpPos=intNextTagPos + i - 2;
									strTgtTag = strRepBody_i.substring(intTmpPos, intTmpPos + 1);
									objLog.info("「※再帰対象：対象」" +  (intPos_i + i) + "番目の文字(タグ含めて)" + (intTmpPos)+ "番目の文字「" + strTgtTag + "」はタグの一部なので処理を飛ばします。");
									intTagOffset_i++;
									objLog.info("現在のintTagOffset:" + intTagOffset_i);
								} else {
									strTgtTag = "";
									int intTmpPos=0;
									intTmpPos=intNextTagPos + i - 2;
									strTgtTag = strRepBody_i.substring(intTmpPos, intTmpPos + 1);
									objLog.info("「再帰の通常処理」" + (i) + "番目の文字(タグ含めて)" + (intTmpPos)+ "番目の文字「" + strTgtTag + "」");
									strRepBody_i = strRepBody_i.substring(0, intTmpPos) + "■"+ strRepBody_i.substring(intTmpPos + 1, strRepBody_i.length());

									hashRepPos_i.put((i),1); //処理終わりフラグ
								} //if
							} //for

						}else { //再帰の再帰
//							int intIndex = intTagOffset_i + 1;
							int intIndex = intTagOffset_i;
							for (int i = 0; i < intIndex; i++) {
								if (intPartTagPos - 2 < i) { //タグの途中などのポジション以上なら自身を再帰呼び出し
									strTgtTag = "";
									int intTmpPos=0;
									intTmpPos=intNextTagPos + i - 1;
									strTgtTag = strRepBody_i.substring(intTmpPos, intTmpPos + 1);
									objLog.info("「※再帰の再帰対象：対象」" +  (intPos_i + i) + "番目の文字(タグ含めて)" + (intTmpPos)+ "番目の文字「" + strTgtTag + "」はタグの一部なので処理を飛ばします。");
									intTagOffset_i++;
									objLog.info("現在のintTagOffset:" + intTagOffset_i);

								} else {
									//Offcet処理なのでhashRepPos_iの情報は見ない
									strTgtTag = "";
									int intTmpPos=0;
									intTmpPos=intNextTagPos + i - 1;
									strTgtTag = strRepBody_i.substring(intTmpPos, intTmpPos + 1);
									//intNextPosは使わないかも、呼び元に依存
									objLog.info("「再帰の再帰通常処理」" + (i + intNextPos) + "番目の文字(タグ含めて)" + (intTmpPos)+ "番目の文字「" + strTgtTag + "」");
									strRepBody_i = strRepBody_i.substring(0, intTmpPos) + "■"+ strRepBody_i.substring(intTmpPos + 1, strRepBody_i.length());
									hashRepPos_i.put((i + intNextPos),1); //処理終わりフラグ
									intTagOffset_i=0; //intTagOffset_iの初期化
								} //if
							} //for
						} //if

						if(intTagOffset_i!=0) {
							objLog.info("タグ分のオフセット処理を行います(再帰処理)");
							refHashRet_i.put("strRepBody",strRepBody_i);
							refHashRet_i.put("intInit","0");
							bodyRecursAct(hashRepPos_i, refHashRet_i, strOrgTagDelBody_i, intNextPos, intNextTagPos, intTagOffset_i,entActGr_i);
							intTagOffset_i=0;
							return ;
						} //if

					}else { //通常処理
						if(intTagOffset_i==0) {
							for (int i = intInitPos; i < intInitPos + intEndPos; i++) {
								//下記の条件だけ処理する
								//hashRepPos_i含まれているか
								if (hashRepPos_i.containsKey( i )) {
									if(hashRepPos_i.get(i) == 0) {
										strTgtTag = "";
										int intTmpPos=0;
										intTmpPos=intNextTagPos + i - 2;
										strTgtTag = strRepBody_i.substring(intTmpPos, intTmpPos + 1);
										//intNextPosは使わないかも、呼び元に依存
										objLog.info("「通常処理」" + (i) + "番目の文字(タグ含めて)" + (intTmpPos)+ "番目の文字「" + strTgtTag + "」");
										strRepBody_i = strRepBody_i.substring(0, intTmpPos) + "■"+ strRepBody_i.substring(intTmpPos + 1, strRepBody_i.length());
										hashRepPos_i.put((i),1); //処理終わりフラグ
									} //if
								} //if
							} //for
						}else { //再帰の通常
							for (int i = 0; i < intTagOffset_i; i++) {
								//offcet処理なのでhashRepPos_iの情報は見ない
								strTgtTag = "";
								int intTmpPos=0;
								intTmpPos=intNextTagPos + i - 1;
								strTgtTag = strRepBody_i.substring(intTmpPos, intTmpPos + 1);
								objLog.info("「再帰通常処理」" + (i + intNextPos) + "番目の文字(タグ含めて)" + (intTmpPos)+ "番目の文字「" + strTgtTag + "」");
								strRepBody_i = strRepBody_i.substring(0, intTmpPos) + "■"+ strRepBody_i.substring(intTmpPos + 1, strRepBody_i.length());
								hashRepPos_i.put((i + intNextPos),1); //処理終わりフラグ
							} //for
						} //if
					} //if
//			} //for
			refHashRet_i.put("intInit","0"); //初期処理フラグを落とす

			break;

			//		} while (objNextMatch.find()); // マッチした数だけループする
		} //while // マッチした数だけループする


		//hashに詰め込む
		refHashRet_i.put("strRepBody",strRepBody_i);


	} //tagOffset



	/**
	 * 連続文字置換時にtagが含まれるか判定する
	 * @param hashRepPos_i 全文検索に渡して加工した文字列置換する情報
	 * @param strRepBody_i 現在変換中のBody
	 * @param intPos_i tagを覗いた文字列の距離
	 * @param intTagPos_i タグを含めたstrが始まるまでの距離
	 * @param entActGr_i 現在の全文検索グループ
	 * @param strRremainTag_i 現在検索中の文字までタグを覗いた文字列
	 * @param intTagOffset_i 再帰処理のオフセット距離
	 * @return 必要な情報を詰め込んだhash
	 */
	public HashMap<String, String> chkTagBeteen(
			HashMap<Integer, Integer> hashRepPos_i,
			String strRepBody_i,
			int intPos_i,
			int intTagPos_i,
			Map.Entry<Integer, Integer> entActGr_i,
			String strRremainTag_i,
			int intTagOffset_i) {
		HashMap<String, String> hashRet = new HashMap<String, String>();
		String strCheckTag = ""; //連続するhashRepPos_iの中にタグが含まれているか判定
		int intInitPos = 0; //現処理のスタート
		int intEndPos = 0; //現処理のエンド

		if(intTagOffset_i==0) {
			intInitPos = entActGr_i.getKey();
			intEndPos = entActGr_i.getValue();
		}else { //offcet時はintInitPos、intEndPosを変更
			intInitPos = 1;
			intEndPos=intTagOffset_i;
		} //if

		//現在のGrの連続する距離を出す
		strCheckTag = "";
		//strCheckTagは一度ループして取得
		for (int i = intInitPos; i < intInitPos +intEndPos; i++) {
			int intTmpPos = i - 1 ;
			strCheckTag += strRremainTag_i.substring(intTmpPos, intTmpPos + 1);
		} //for


		//連続した距離内にタグがあるか判定する
		Pattern objPatBiteen = Pattern.compile("\\<|\\</|\\>|/"); //strCheckTag内にタグの途中などがあるかチェック
		Matcher objMatchBiteen = objPatBiteen.matcher(strCheckTag);
		boolean blMatchBiteen = objMatchBiteen.find();
		String strPartTag = "";
		int intPartTagPos = 0;
		if (blMatchBiteen) { //strCheckTag内にタグの途中などがあった場合、文字数をカウントしてタグ以外を塗る
			//			System.out.println(strCheckTag);
			objLog.info("a連続処理中のタグチェック値「" + strCheckTag + "」");
			strPartTag = objMatchBiteen.group();
			//			intPartTagPos = strCheckTag.indexOf(strPartTag); //strCheckTag内にタグの途中などのポジション
			intPartTagPos = strCheckTag.indexOf(strPartTag) + 1; //strCheckTag内にタグの途中などのポジション
		} //if

		//必要な情報を詰め込む
		hashRet.put("blMatchBiteen",String.valueOf(blMatchBiteen)); //連続した文字列にタグが含まれるか
		hashRet.put("strCheckTag",strCheckTag); //連続した文字列にタグが含まれるか
		hashRet.put("strPartTag",strPartTag); //正規表現でヒットしたタグ
		hashRet.put("intPartTagPos",String.valueOf(intPartTagPos)); //strCheckTag内にタグの途中などのポジション
		hashRet.put("intEndPos",String.valueOf(intEndPos));

		return hashRet;

	} //chkTagBeteen

	/**
	 * htmlのbodyの中身を入れ替え、置換HTMLを作成する
	 * @param strAllHtml_i
	 * @param strRepBody_i
	 * @return 置換処理を行ったHTMLString
	 */
	public String makeBody(String strAllHtml_i, String strRepBody_i) {
		String strRet = strAllHtml_i;
		//改行を削除
		strRet = strRet.replaceAll("\r\n", " ");
		//tag以外で必要以外の半角スペース削除
		strRet.replaceAll("\\s+\\s", " ");

		String strPattern = "\\<body\\>.+\\</body\\>";

		//Bodyを入れ替え
		//		strRet=strRet.replaceAll(strPattern, strRepBody_i);
		strRet = strRet.replaceFirst(strPattern, strRepBody_i);
		return strRet;
	} //getBody


	/**
	 * strpath_iで指定したファイルを改行付きですべて読み込む
	 * @param strpath_i
	 * @return 読み込んだ文字列
	 * @throws IOException
	 */
	public String readAll(final String strpath_i) throws IOException {
		return Files.lines(Paths.get(strpath_i), Charset.forName("UTF-8"))
				.collect(Collectors.joining(System.getProperty("line.separator")));

	} //readAll

	/**
	 * strHtml_i(htmlString)のBodyを正規表現で抜き出す(改行 必要以外の半角スペース削除)
	 * @param strHtml_i
	 * @return 抜き出したBody
	 */
	public String getBodyCompress(String strHtml_i) {
		String strRet = strHtml_i;

		//改行を削除
		strRet = strRet.replaceAll("\r\n", "");

		//2つ以上の半角スペースを一つにまとめる
		strRet = strRet.replaceAll("\\s+", " ");

		String strPattern = "\\<body\\>.+\\</body\\>";
		Pattern objPattern = Pattern.compile(strPattern);
		Matcher objMatch = objPattern.matcher(strRet);
		boolean blRet = objMatch.find();
		strRet = objMatch.group();

		return strRet;
	} //getBody

	/**
	 * 全文検索エンジンに渡す用の文字列を取得する
	 * @param strBody_i HTML文字列からBody要素だけを抜き出したもの
	 * @return タグ無し連結文字列
	 */
	public String getIllegalText(String strBody_i) {
		String strRet = strBody_i;
		//tagを全て除去
		String strPattern = "<(\"[^\"]*\"|'[^']*'|[^'\">])*>";
		strRet = strRet.replaceAll(strPattern, "");
		//trim
		strRet = strRet.trim();

		//半角スペース記号置換
		//		strPattern="&#xa0;";
		//		strRet = strRet.replace(strPattern, " ");

		return strRet;
	} //getIllegalText

	/**
	 * 全文検索から戻ってきた値をkeyで当てはまったハッシュをすべて変換するよう成型する
	 * ※来るデータはカンマ区切りで「startポジション,startポジションから〇〇文字」を想定
	 * @param strTextSrh_i 全文検索から帰ってきた文字列
	 * @param hashRetGr_i ハッシュのグループ(参照)
	 * @return 成型したハッシュ
	 */
	public HashMap<Integer, HashMap<Integer, Integer>> makePosHash(String strTextSrh_i,HashMap<Integer, Integer> hashRetGr_i) {

//		HashMap<Integer, Integer> hashRet = new HashMap<Integer, Integer>();
		//key：Gr varl Grで対応する値
		HashMap<Integer, HashMap<Integer, Integer>> hashRet = new HashMap<Integer, HashMap<Integer, Integer>>();


		String[] arrTgt = strTextSrh_i.split(",");

		//Grの作成
		for (int i = 0; i < arrTgt.length; i+=2) {
			hashRetGr_i.put(Integer.parseInt(arrTgt[i]),Integer.parseInt(arrTgt[i + 1]));
		} //for

		//Grの数だけhashを作成
		for (int intKey : hashRetGr_i.keySet()) {
			HashMap<Integer, Integer> hashTmp = new HashMap<Integer, Integer>();
			hashRet.put(intKey, hashTmp);
		} //for

		//Gr毎にフラグ管理
		for (int i = 0; i < arrTgt.length; i++) {
			Integer intTmp = Integer.parseInt(arrTgt[i]);
			if (i % 2 == 0) { //偶数ならkeyを作成
				if (intTmp <= 0) { //※1文字目からカウントするので
					String strErrMtg = "文字は1文字目からカウントします。置換対象文字位置「" + intTmp + "」";
					objLog.error(strErrMtg);
					throw new IllegalArgumentException(strErrMtg);
				} //if
				Integer intEnd = Integer.parseInt(arrTgt[i + 1]) + (intTmp - 1);
				HashMap<Integer, Integer> hashTmp = hashRet.get(intTmp);
				for (int j = intTmp; j <= intEnd; j++) {
					hashRet.get(intTmp).put(j, 0);
				} //for
			} //if
		} //for


		return hashRet;
	} //makePosHash




} //class
