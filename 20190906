package htmlMaskTest;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.apache.log4j.Logger;

public class HtmlMaskTest {
	static Logger objLog = Logger.getLogger(HtmlMaskTest.class);

	public static void main(String[] args) {

		HtmlMaskTest objMe = new HtmlMaskTest();
		FileWriter file;
		PrintWriter pw;

		//全文検索モックデータ カンマ区切りで番号が来ると予想 intpos,そこからつづく,intpos,そこからつづく
		//※開始は1文字目から
		//		String strTestData = "9,3,30,2";
		//		String strTestData = "1,2,9,10,100,2,105,2";
		//		String strTestData = "200,20";
		//		String strTestData = "0,2,9,3,100,2";
//		String strTestData = "2,8";
//		String strTestData = "2,2,5,2";
		String strTestData = "2,10";
//		String strTestData = "19,2";
		//htmlをすべて読み込む
		//		String strDir = "//yoks3104/Project/NES_文書管理システム/99_tmp/上田/aspTest/";
		String strDir = "C:/Users/ueda tatsuya/Desktop/20190826/20190826/repTest/";
				String strFileName = "test.docasp_1566802594082.html";
//		String strFileName = "test_黒塗り調査用.html";
		String strDlFilePath = strDir + strFileName;
		String strAllHtml = "";
		String strOrgBody = "";
		String strNotTagBody = "";
		String strRepBody = "";
		String strMaskHtml = "";
		int intMaskStatsu = 1;


		String strBkBody="";

		try {
			strAllHtml = objMe.readAll(strDlFilePath);

			//圧縮されたBodyを取得
			strOrgBody = objMe.getBodyCompress(strAllHtml);

			//全文検索エンジンに渡す用の文字列を取得する
			strNotTagBody = objMe.getIllegalText(strOrgBody);

			//			※※※※※※※検索エンジンに送ったと想定※※※※※※※

			//全文検索から戻ってきた値をhashへ成型
			HashMap<Integer, Integer> hashRepPos = objMe.makePosHash(strTestData);

			//全文検索エンジンに返した結果を置換してbodyを入れ替えた文字列を取得
			strRepBody = objMe.bodyReplace(hashRepPos, strOrgBody, strNotTagBody, intMaskStatsu);
			//htmlのbodyの中身を入れ替え、置換HTMLを作成する
			strMaskHtml = objMe.makeBody(strAllHtml, strRepBody);

			//htmlを出力する
			//			//debug tmpに出力
			file = new FileWriter(strDir + "test.html");
			pw = new PrintWriter(new BufferedWriter(file));
			pw.println(strMaskHtml);
			pw.close();
			objLog.info("完了");

			//			System.out.println(strOrgBody);

		} catch (IOException e) {
			// TODO 自動生成された catch ブロック
			e.printStackTrace();
		} //try

	} //main

	/**
	 * strpath_iで指定したファイルを改行付きですべて読み込む
	 * @param strpath_i
	 * @return 読み込んだ文字列
	 * @throws IOException
	 */
	public String readAll(final String strpath_i) throws IOException {
		return Files.lines(Paths.get(strpath_i), Charset.forName("UTF-8"))
				.collect(Collectors.joining(System.getProperty("line.separator")));

	} //readAll

	/**
	 * strHtml_i(htmlString)のBodyを正規表現で抜き出す(改行 必要以外の半角スペース削除)
	 * @param strHtml_i
	 * @return 抜き出したBody
	 */
	public String getBodyCompress(String strHtml_i) {
		String strRet = strHtml_i;

		//改行を削除
		strRet = strRet.replaceAll("\r\n", "");

		//2つ以上の半角スペースを一つにまとめる
		strRet = strRet.replaceAll("\\s+", " ");

		String strPattern = "\\<body\\>.+\\</body\\>";
		Pattern objPattern = Pattern.compile(strPattern);
		Matcher objMatch = objPattern.matcher(strRet);
		boolean blRet = objMatch.find();
		strRet = objMatch.group();

		return strRet;
	} //getBody

	/**
	 * 全文検索エンジンに渡す用の文字列を取得する
	 * @param strBody_i HTML文字列からBody要素だけを抜き出したもの
	 * @return タグ無し連結文字列
	 */
	public String getIllegalText(String strBody_i) {
		String strRet = strBody_i;
		//tagを全て除去
		String strPattern = "<(\"[^\"]*\"|'[^']*'|[^'\">])*>";
		strRet = strRet.replaceAll(strPattern, "");
		//trim
		strRet = strRet.trim();

		//半角スペース記号置換
		//		strPattern="&#xa0;";
		//		strRet = strRet.replace(strPattern, " ");

		return strRet;
	} //getIllegalText

	/**
	 * 全文検索から戻ってきた値をkeyで当てはまったハッシュをすべて変換するよう成型する
	 * ※来るデータはカンマ区切りで「startポジション,startポジションから〇〇文字」を想定
	 * @param strTextSrh_i 全文検索から帰ってきた文字列
	 * @return 成型したハッシュ
	 */
	public HashMap<Integer, Integer> makePosHash(String strTextSrh_i) {
		HashMap<Integer, Integer> hashRet = new HashMap<Integer, Integer>();

		String[] arrTgt = strTextSrh_i.split(",");
		//		boolean blInit = false; //スタートが0の時だけ特別処理
		for (int i = 0; i < arrTgt.length; i++) {
			Integer intTmp = Integer.parseInt(arrTgt[i]);
			if (i % 2 == 0) { //偶数ならkeyを作成
				if (intTmp <= 0) { //※1文字目からカウントするので
					String strErrMtg = "文字は1文字目からカウントします。置換対象文字位置「" + intTmp + "」";
					objLog.error(strErrMtg);
					throw new IllegalArgumentException(strErrMtg);
				} //if
//				Integer intEnd = Integer.parseInt(arrTgt[i + 1]) + intTmp;
				Integer intEnd = Integer.parseInt(arrTgt[i + 1]) + (intTmp - 1);
				int intCnt = 0;
				for (int j = intTmp; j <= intEnd; j++) {
					hashRet.put(j, 0);
					intCnt = j;
				} //for

			} //if

		} //for

		return hashRet;

	} //makePosHash

	/**
	 * 全文検索エンジンに返した結果を置換してbodyを入れ替え、または赤文字変換した文字列を取得
	 * @param hashTest
	 * @param strOrgBody_i
	 * @param intStatus_i 置換ステータス :マスク 2:赤文字
	 * @return 置換したBody文字列
	 */
	public String bodyReplace(HashMap<Integer, Integer> hashRepPos_i, String strOrgBody_i, String strOrgTagDelBody_i,
			int intStatus_i) {
		String strTgtVal = strOrgBody_i;

		String strRegrep = "(<\\/?[^>]+>)|([^<]+)"; //タグを覗いた値を取得する
		Pattern objPattern = Pattern.compile(strRegrep);
		Matcher objMatch = objPattern.matcher(strTgtVal);

		int intPos = 0; //tagを覗いた文字列の距離
		int intTagPos = 0; //タグを含めたstrが始まるまでの距離
		String strCurrentKwd = ""; //現在ヒットしている単語
		int intTagOffset = 0; //連続文字処理中にあるタグの分の文字数をカウント
		HashMap<String, Integer> hashKwdPos = new HashMap<String, Integer>(); //strCurrentKwdのポジションを格納する key:キーワード val：ポジション
		boolean blMatch = objMatch.find();
		do {


			strCurrentKwd = objMatch.group(2);
			if (strCurrentKwd == null)
				continue; //タグに文字列にマッチはスキップ
			if (strCurrentKwd.equals(" "))
				continue; //半角スペースはスキップ
			if (hashKwdPos.containsKey(strCurrentKwd)) { //すでにKeyに入っているか確認
				hashKwdPos.put(strCurrentKwd, hashKwdPos.get(strCurrentKwd) + 1); //次の検索へ
			} else {
				hashKwdPos.put(strCurrentKwd, 0); //最初の検索
			} //if

			//※※※※※※単語単位で引っ掛けちゃだめ。ヘッダーtestとtestとかで違うと認識されて誤爆する
			//findでintTagPosをとって、タグ消す正規表現でintPosだす？
//			intTagPos = strTgtVal.indexOf(strCurrentKwd, hashKwdPos.get(strCurrentKwd)) + 1;
//			intPos = strOrgTagDelBody_i.indexOf(strCurrentKwd, hashKwdPos.get(strCurrentKwd)) + 1;

			intTagPos = objMatch.start() + 1;
			String strRremainTag = strTgtVal.substring(intTagPos -1,strTgtVal.length()); //tagを含めた残りの文字
			String strRremainStr = getIllegalText(strRremainTag); //タグを覗いた残りのstring
			String strAcriveStr = getIllegalText(strTgtVal); //変換後のタグを覗いた全てのstring
			intPos = strAcriveStr.indexOf(strRremainStr) + 1;

			if(intTagPos==0) {
				continue;
			} //intTagPosが0以下になるのは先読みして置換した場合
			//ただし、赤文字に対応できないので暫定で処理飛ばし

			int intCnt = 0;
			int intOffcet = 0;
			int intLogCnt = 0;
			String strTgtTag = "";
			boolean blActFlg = false; //処理を行うかのフラグ

			for (int intKey : hashRepPos_i.keySet()) {
//				if (hashRepPos_i.containsKey(intPos + (intKey - 1) )) {
				if (hashRepPos_i.containsKey(intPos + (intKey - 1) )) {
					if(hashRepPos_i.get(intPos + (intKey - 1) ) == 0) { //未処理の場合だけフラグを建てる
						blActFlg = true;
						intPos = intPos + (intKey - 1); //スタートを切り替える
						break;
					}//if

				} //if
			} //for

			intCnt = 0;
			//以降はblActFlgがtrueの時だけ
//			if (hashBeteen.get("biteeenFlg").equals("true")) {
			if (blActFlg) {

				//連続処理中にタグが含まれるか判定する
				HashMap<String, String> hashBeteen = chkTagBeteen(hashRepPos_i, strTgtVal, intPos, intTagPos);
				String strCheckTag = hashBeteen.get("strCheckTag"); //連続するhashRepPos_iの中にタグが含まれているか判定
				boolean blMatchBiteen = hashBeteen.get("blMatchBiteen").equals("true");
				String strPartTag = hashBeteen.get("strPartTag");
				int intPartTagPos = Integer.parseInt(hashBeteen.get("intPartTagPos"));
				int intEndPos = Integer.parseInt(hashBeteen.get("intEndPos"));

				intCnt = 0;
				for (int i = 0; i < intEndPos; i++) {
					//					while (hashRepPos_i.containsKey(intPos + intCnt)) {

					if (intStatus_i == 1) { //文字列置換
						if (blMatchBiteen) { //部分的にタグが入っている場合
							objLog.info("「" +strCheckTag +"」は連続した文字列内にタグが含まれいるので特殊処理します。");
							if (intPartTagPos <= intCnt) { //タグの途中などのポジション以上なら処理を飛ばす
								strTgtTag = "";
								int intTmpPos=intTagPos + intCnt - 1 + (intPos - 1);
								strTgtTag = strTgtVal.substring(intTmpPos, intTmpPos + 1);
//								strTgtTag = strTgtVal.substring(intTagPos + intCnt - 1 + (intPos - 1), intTagPos + intCnt + (intPos - 1));
								objLog.info("「※処理飛ばし：マスク対象」" + (intPos + intLogCnt) + "番目の文字(タグ含めて)"+ (intTagPos + intCnt) + "番目の文字「" + strTgtTag + "」はタグの一部なので処理を飛ばします。");
								intTagOffset++;
								objLog.info("現在のintTagOffset:" + intTagOffset);
							} else {
								strTgtTag = "";
								int intTmpPos=intTagPos + intCnt - 1 + (intPos - 1);
								strTgtTag = strTgtVal.substring(intTmpPos, intTmpPos + 1);
//								strTgtTag = strTgtVal.substring(intTagPos + intCnt - 1 + (intPos - 1), intTagPos + intCnt + (intPos - 1));
								objLog.info("「マスク対象」" + (intPos + intLogCnt) + "番目の文字(タグ含めて)" + (intTagPos + intCnt)+ "番目の文字「" + strTgtTag + "」");
//								strTgtVal = strTgtVal.substring(0, intTagPos + intCnt - 1 + (intPos - 1) ) + "■"+ strTgtVal.substring(intTagPos + intCnt + (intPos - 1), strTgtVal.length());
								strTgtVal = strTgtVal.substring(0, intTmpPos ) + "■"+ strTgtVal.substring(intTmpPos + 1, strTgtVal.length());
								hashRepPos_i.put((intPos - 1 + i),1); //処理終わりフラグ
								intLogCnt++;
							} //if


						} else {
							strTgtTag = "";
							int intTmpPos=intTagPos + intCnt - 1 + (intPos - 1);
							strTgtTag = strTgtVal.substring(intTmpPos, intTmpPos + 1);
//							strTgtTag = strTgtVal.substring(intTagPos + intCnt - 1 + (intPos - 1), intTagPos + intCnt + (intPos - 1));
							objLog.info("「マスク対象」" + (intPos + intLogCnt) + "番目の文字(タグ含めて)" + (intTagPos + intCnt)+ "番目の文字「" + strTgtTag + "」");
//							strTgtVal = strTgtVal.substring(0, intTagPos + intCnt - 1 + (intPos - 1) ) + "■"+ strTgtVal.substring(intTagPos + intCnt + (intPos - 1), strTgtVal.length());
							strTgtVal = strTgtVal.substring(0, intTmpPos ) + "■"+ strTgtVal.substring(intTmpPos + 1, strTgtVal.length());
							hashRepPos_i.put((intPos - 1 + i),1); //処理終わりフラグ
							intLogCnt++;

						} //if



					} else { //赤文字
						strTgtTag = "";
						strTgtTag = strTgtVal.substring(intTagPos + intCnt + intOffcet - 1,
								intTagPos + intCnt + intOffcet);
						objLog.info("「赤文字対象」" + (intPos + intLogCnt) + "番目の文字(タグ含めて)" + (intTagPos + intCnt) + "番目の文字「"
								+ strTgtTag + "」");
						strTgtTag = "<span style='color:#c9f522'>" + strTgtTag + "</span>";
						//                		  strTgtTag = "<span style='color:#ff0000'>" + strTgtTag + "</span>";
						strTgtVal = strTgtVal.substring(0, intTagPos + intCnt + intOffcet - 1) + strTgtTag
								+ strTgtVal.substring(intTagPos + intCnt + intOffcet, strTgtVal.length());
						intOffcet = intOffcet + strTgtTag.length() - 1;
						intLogCnt++;
					} //if
					intCnt++;
				} //for

				if(intTagOffset !=0) { //intTagOffsetでオフセットしている場合
					objLog.info("タグ分のオフセット処理を行います");
					HashMap<String, String> refHashRet = new HashMap<String, String>();
					refHashRet.put("strRepBody",strTgtVal);
					refHashRet.put("return","0"); //再起確認ステータス 0:最初の処理で終わり、1:再帰処理あり

//					tagOffset(hashRepPos_i, refHashRet, strOrgTagDelBody_i, intPos, intTagPos, intTagOffset);
					tagOffset(hashRepPos_i, refHashRet, strOrgTagDelBody_i, intPos, intTagPos, intTagOffset,hashKwdPos);
					strTgtVal = refHashRet.get("strRepBody");


				} //if
				intTagOffset = 0;

			} //if

		} while (objMatch.find()); // マッチした数だけループする

		return strTgtVal;
	} //bodyReplace


	/**
	 * intTagOffsetが0になるまでtag分のオフセット処理を行う
	 * @param hashRepPos_i 全文検索に渡して加工した文字列置換する情報
	 * @param strRepBody_i 現在変換中のBody
	 * @param intPos_i tagを覗いた文字列の距離
	 * @param intTagPos_i タグを含めたstrが始まるまでの距離
	 * @return
	 */
	public void tagOffset(HashMap<Integer, Integer> hashRepPos_i,HashMap<String, String> refHashRet_i,String strOrgTagDelBody_i, int intPos_i, int intTagPos_i,int intTagOffset_i,HashMap<String, Integer> hashKwdPos_i) {
//		String strAfter = strTgtVal.substring(intTagPos + intCnt + (intPos - 1), strTgtVal.length()); //処理残りの文字列
		String strRepBody_i = refHashRet_i.get("strRepBody");

		int intCnt=0;
		String strRegrep = "(<\\/?[^>]+>)|([^<]+)"; //タグを覗いた値を取得する
		Pattern objPattern = Pattern.compile(strRegrep);
		String strAfter = strRepBody_i.substring(intTagPos_i + intTagOffset_i, strRepBody_i.length());
		//最初の閉じタグまで削除
		strAfter = strAfter.replaceFirst("^.+?>", "");
		Matcher objNextMatch = objPattern.matcher(strAfter);
		boolean blNextMatch = objNextMatch.find();
//		blNextMatch = objNextMatch.find(); //必ず中途半端なタグに引っかかるから2回findしておく
		HashMap<String, Integer> hashNextKwdPos = new HashMap<String, Integer>();
		do {
			intCnt = 0;
			String strNextCurrentKwd = objNextMatch.group(2);
			if (strNextCurrentKwd == null)
				continue; //タグに文字列にマッチはスキップ
			if (strNextCurrentKwd.equals(" "))
				continue; //半角スペースはスキップ
			if (hashNextKwdPos.containsKey(strNextCurrentKwd)) { //すでにKeyに入っているか確認
				hashNextKwdPos.put(strNextCurrentKwd, hashNextKwdPos.get(strNextCurrentKwd) + 1); //次の検索へ
			} else {
				hashNextKwdPos.put(strNextCurrentKwd, 0); //最初の検索
			} //if

			//※※※※※strNextCurrentKwdがなんかずれる？

			int intNextTagPos = strRepBody_i.indexOf(strAfter);
			intNextTagPos = strRepBody_i.indexOf(strAfter) + 1;
//			String strRremainTag = strRepBody_i.substring(intNextTagPos -1,strRepBody_i.length()); //tagを含めた残りの文字
//			String strRremainTag = strRepBody_i.substring(strRepBody_i.indexOf(strAfter),strRepBody_i.length()); //tagを含めた残りの文字
			String strRremainTag = strRepBody_i.substring(intNextTagPos,strRepBody_i.length()); //tagを含めた残りの文字
			String strRremainStr = getIllegalText(strRremainTag); //タグを覗いた残りのstring
			String strAcriveStr = getIllegalText(strRepBody_i); //変換後のタグを覗いた全てのstring


			int intNextPos = strAcriveStr.indexOf(strRremainStr) + 1;


			if(intNextTagPos==0) {
				System.out.println();
			}

			String strTgtTag="";

			//連続処理中にタグが含まれるか判定する
//			HashMap<String, String> hashBeteen = chkTagBeteen(hashRepPos_i, strRepBody_i, intNextPos, intNextTagPos);
			HashMap<String, String> hashBeteen = chkTagBeteenOffset(intTagOffset_i, strRepBody_i, intNextPos, intNextTagPos);
			String strCheckTag = hashBeteen.get("strCheckTag"); //連続するhashRepPos_iの中にタグが含まれているか判定
			boolean blMatchBiteen = hashBeteen.get("blMatchBiteen").equals("true");
			String strPartTag = hashBeteen.get("strPartTag");
			int intPartTagPos = Integer.parseInt(hashBeteen.get("intPartTagPos"));
			int intActTagOffset = 0;

			if (blMatchBiteen) { //部分的にタグが入っている場合
				objLog.info("「" +strCheckTag +"」は連続した文字列内にタグが含まれいるので特殊処理します。");
				String strSkip="";
				for (int i = 0; i < intTagOffset_i; i++) {
//					if (intPartTagPos <= intCnt) { //タグの途中などのポジション以上なら自身を再帰呼び出し
					if (intPartTagPos <= i) { //タグの途中などのポジション以上なら自身を再帰呼び出し
						strTgtTag = "";
						int intTmpPos=intNextTagPos + i - 1;
						strTgtTag = strRepBody_i.substring(intTmpPos, intTmpPos + 1);
//						strTgtTag = strRepBody_i.substring(intNextTagPos + i - 1 , intNextTagPos + i);
						objLog.info("「※処理飛ばし：マスク対象」" + (intNextPos - 1 + i) + "番目の文字(タグ含めて)" + (intNextTagPos + intCnt)+ "番目の文字「" + strTgtTag + "」");
						intActTagOffset++;
						hashRepPos_i.put((intNextPos - 1 + i),1); //処理終わりフラグ

					} else {
						strTgtTag = "";
						int intTmpPos=intNextTagPos + i - 1;
						strTgtTag = strRepBody_i.substring(intTmpPos, intTmpPos + 1);
//						strTgtTag = strRepBody_i.substring(intNextTagPos + i - 1 , intNextTagPos + i);
						objLog.info("「aオフセットマスク対象」" + (intNextPos - 1 + i) + "番目の文字(タグ含めて)" + (intNextTagPos + intCnt)+ "番目の文字「" + strTgtTag + "」");
						strRepBody_i = strRepBody_i.substring(0, intNextTagPos  + i -1 ) + "■"+ strRepBody_i.substring(intNextTagPos  + i, strRepBody_i.length());
						strSkip+=strTgtTag;
						hashRepPos_i.put((intNextPos - 1 + i),1); //処理終わりフラグ
					} //if
				} //for

				if (!strSkip.equals("")) {
					//ここでoffset分のポジションを入れておく
					if (hashKwdPos_i.containsKey(strSkip)) { //すでにKeyに入っているか確認
						hashKwdPos_i.put(strSkip, hashKwdPos_i.get(strSkip) + 1); //次の検索へ
					} else {
						hashKwdPos_i.put(strSkip, 0); //最初の検索
					} //if
				}//if


				if(intActTagOffset!=0) {
					objLog.info("タグ分のオフセット処理を行います(再帰処理)");
					refHashRet_i.put("strRepBody",strRepBody_i);
					tagOffset(hashRepPos_i, refHashRet_i, strOrgTagDelBody_i, intNextPos, intNextTagPos, intActTagOffset,hashKwdPos_i);
					return ;
				} //if

			}else {
				for (int i = 0; i < intTagOffset_i; i++) {
					strTgtTag = "";
					int intTmpPos=intNextTagPos + i - 1;
					strTgtTag = strRepBody_i.substring(intTmpPos, intTmpPos + 1);
//					objLog.info("「bオフセットマスク対象」" + (intNextPos - 1 + i) + "番目の文字(タグ含めて)" + (intNextTagPos + intCnt)+ "番目の文字「" + strTgtTag + "」");
					objLog.info("「bオフセットマスク対象」" + (intNextPos + i) + "番目の文字(タグ含めて)" + (intNextTagPos + intCnt)+ "番目の文字「" + strTgtTag + "」");
					strRepBody_i = strRepBody_i.substring(0, intNextTagPos  + i -1 ) + "■"+ strRepBody_i.substring(intNextTagPos  + i, strRepBody_i.length());
					hashRepPos_i.put((intNextPos - 1 + i),1); //処理終わりフラグ
				} //for
//				break;
			} //if


			break;

		} while (objNextMatch.find()); // マッチした数だけループする


		//hashに詰め込む
		refHashRet_i.put("strRepBody",strRepBody_i);


	} //tagOffset



	/**
	 * 連続文字置換時にtagが含まれるか判定する
	 * @param hashRepPos_i 全文検索に渡して加工した文字列置換する情報
	 * @param strRepBody_i 現在変換中のBody
	 * @param intPos_i tagを覗いた文字列の距離
	 * @param intTagPos_i タグを含めたstrが始まるまでの距離
	 * @return 必要な情報を詰め込んだhash
	 */
	public HashMap<String, String> chkTagBeteen(HashMap<Integer, Integer> hashRepPos_i,String strRepBody_i, int intPos_i, int intTagPos_i) {
		HashMap<String, String> hashRet = new HashMap<String, String>();
		String strCheckTag = ""; //連続するhashRepPos_iの中にタグが含まれているか判定
		int intCnt=0;
		int intScope=0; //連続したポジションか確認用

//		int intInitPos = 0; //現処理のスタート
		int intEndPos = 0; //現処理のエンド

		//現在のポジション(intPos_i)から連続した距離を出す
		for (int intKey : hashRepPos_i.keySet()) {
			if(intScope == 0) { //初期化
				intScope = intKey;
				intCnt++;
				continue;

			} //if

			if (intPos_i>intKey) {
				continue; //現在より少なかったら処理飛ばし
			} //if
			if ( !(hashRepPos_i.containsKey(intScope + 1)) ) {

				break; //2ポジション以上離れていたらbreak
			} else {
				int intTmpPos=intTagPos_i + intCnt - 2 + (intPos_i - 1);
//				strCheckTag += strRepBody_i.substring(intTagPos_i + intCnt - 1 + (intPos_i - 1), intTagPos_i + intCnt + (intPos_i - 1));
				strCheckTag += strRepBody_i.substring(intTmpPos, intTmpPos + 1);
			}
			intScope=intKey;
			intCnt++;
		} //for

		intEndPos = intCnt;


		//連続した距離内にタグがあるか判定する
//		Pattern objPatBiteen = Pattern.compile("\\<|\\</|>"); //strCheckTag内にタグの途中などがあるかチェック
		Pattern objPatBiteen = Pattern.compile("\\<|\\</|\\>|/"); //strCheckTag内にタグの途中などがあるかチェック
		Matcher objMatchBiteen = objPatBiteen.matcher(strCheckTag);
		boolean blMatchBiteen = objMatchBiteen.find();
		String strPartTag = "";
		int intPartTagPos = 0;
		if (blMatchBiteen) { //strCheckTag内にタグの途中などがあった場合、文字数をカウントしてタグ以外を塗る
			System.out.println(strCheckTag);
			strPartTag = objMatchBiteen.group();
//			intPartTagPos = strCheckTag.indexOf(strPartTag); //strCheckTag内にタグの途中などのポジション
			intPartTagPos = strCheckTag.indexOf(strPartTag) + 1; //strCheckTag内にタグの途中などのポジション
		} //if

		//必要な情報を詰め込む
		hashRet.put("blMatchBiteen",String.valueOf(blMatchBiteen)); //連続した文字列にタグが含まれるか
		hashRet.put("strCheckTag",strCheckTag); //連続した文字列にタグが含まれるか
		hashRet.put("strPartTag",strPartTag); //正規表現でヒットしたタグ
//		hashRet.put("intPartTagPos",String.valueOf(intPartTagPos)); //strCheckTag内にタグの途中などのポジション
//		hashRet.put("intEndPos",String.valueOf(intEndPos));
		//20190905 タグオフセットのずれ修正
		hashRet.put("intPartTagPos",String.valueOf(intPartTagPos - 1)); //strCheckTag内にタグの途中などのポジション
		hashRet.put("intEndPos",String.valueOf(intEndPos - 1));
		return hashRet;

	} //chkTagBeteen



	/**
	 * 連続文字置換時にtagが含まれるか判定する(tagoffset時用)
	 * @param intTagOffset 現在tagが含まれoffceした量
	 * @param strRepBody_i 現在変換中のBody
	 * @param intPos_i tagを覗いた文字列の距離
	 * @param intTagPos_i タグを含めたstrが始まるまでの距離
	 * @return 必要な情報を詰め込んだhash
	 */
	public HashMap<String, String> chkTagBeteenOffset(int intTagOffset,String strRepBody_i, int intPos_i, int intTagPos_i) {
		HashMap<String, String> hashRet = new HashMap<String, String>();
		String strCheckTag = ""; //連続するhashRepPos_iの中にタグが含まれているか判定
		for (int i = 0; i < intTagOffset; i++) {
			strCheckTag += strRepBody_i.substring(intTagPos_i  + i - 1, intTagPos_i  + i);

		} //for


		Pattern objPatBiteen = Pattern.compile("\\<|\\</|>"); //strCheckTag内にタグの途中などがあるかチェック
		Matcher objMatchBiteen = objPatBiteen.matcher(strCheckTag);
		boolean blMatchBiteen = objMatchBiteen.find();
		String strPartTag = "";
		int intPartTagPos = 0;
		if (blMatchBiteen) { //strCheckTag内にタグの途中などがあった場合、文字数をカウントしてタグ以外を塗る
			System.out.println(strCheckTag);
			strPartTag = objMatchBiteen.group();
			intPartTagPos = strCheckTag.indexOf(strPartTag); //strCheckTag内にタグの途中などのポジション
		} //if

		//必要な情報を詰め込む
		hashRet.put("blMatchBiteen",String.valueOf(blMatchBiteen)); //連続した文字列にタグが含まれるか
		hashRet.put("strCheckTag",strCheckTag); //連続した文字列にタグが含まれるか
		hashRet.put("strPartTag",strPartTag); //正規表現でヒットしたタグ
		hashRet.put("intPartTagPos",String.valueOf(intPartTagPos)); //strCheckTag内にタグの途中などのポジション

		return hashRet;

	} //chkTagBeteen




	/**
	 * htmlのbodyの中身を入れ替え、置換HTMLを作成する
	 * @param strAllHtml_i
	 * @param strRepBody_i
	 * @return 置換処理を行ったHTMLString
	 */
	public String makeBody(String strAllHtml_i, String strRepBody_i) {
		String strRet = strAllHtml_i;
		//改行を削除
		strRet = strRet.replaceAll("\r\n", " ");
		//tag以外で必要以外の半角スペース削除
		strRet.replaceAll("\\s+\\s", " ");

		String strPattern = "\\<body\\>.+\\</body\\>";

		//Bodyを入れ替え
		//		strRet=strRet.replaceAll(strPattern, strRepBody_i);
		strRet = strRet.replaceFirst(strPattern, strRepBody_i);
		return strRet;
	} //getBody

	/**
	 * 全角文字は２桁、半角文字は１桁として文字数をカウントする
	 * @param str 対象文字列
	 * @return 文字数
	 */
	public int getHan1Zen2(String str) {

		//戻り値
		int ret = 0;

		//全角半角判定
		char[] c = str.toCharArray();
		for (int i = 0; i < c.length; i++) {
			if (String.valueOf(c[i]).getBytes().length <= 1) {
				ret += 1; //半角文字なら＋１
			} else {
				ret += 2; //全角文字なら＋２
			}
		}

		return ret;
	} //getHan1Zen2


} //class
